<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=iMc4-4exjgqA-toZgqqJBf35jAjY-31lSKWZb9Fa77M);.lst-kix_haj85nxwaneu-4>li:before{content:"" counter(lst-ctn-kix_haj85nxwaneu-4,lower-latin) ". "}.lst-kix_haj85nxwaneu-3>li:before{content:"" counter(lst-ctn-kix_haj85nxwaneu-3,decimal) ". "}.lst-kix_haj85nxwaneu-5>li:before{content:"" counter(lst-ctn-kix_haj85nxwaneu-5,lower-roman) ". "}.lst-kix_haj85nxwaneu-2>li:before{content:"" counter(lst-ctn-kix_haj85nxwaneu-2,lower-roman) ". "}.lst-kix_haj85nxwaneu-6>li:before{content:"" counter(lst-ctn-kix_haj85nxwaneu-6,decimal) ". "}.lst-kix_haj85nxwaneu-0>li:before{content:"" counter(lst-ctn-kix_haj85nxwaneu-0,decimal) ". "}.lst-kix_haj85nxwaneu-8>li:before{content:"" counter(lst-ctn-kix_haj85nxwaneu-8,lower-roman) ". "}.lst-kix_haj85nxwaneu-1>li:before{content:"" counter(lst-ctn-kix_haj85nxwaneu-1,lower-latin) ". "}.lst-kix_haj85nxwaneu-7>li:before{content:"" counter(lst-ctn-kix_haj85nxwaneu-7,lower-latin) ". "}.lst-kix_5hjxj1ghwghx-6>li:before{content:"\0025cf   "}.lst-kix_5hjxj1ghwghx-5>li:before{content:"\0025a0   "}.lst-kix_haj85nxwaneu-6>li{counter-increment:lst-ctn-kix_haj85nxwaneu-6}.lst-kix_5hjxj1ghwghx-3>li:before{content:"\0025cf   "}ol.lst-kix_haj85nxwaneu-7.start{counter-reset:lst-ctn-kix_haj85nxwaneu-7 0}.lst-kix_5hjxj1ghwghx-4>li:before{content:"\0025cb   "}.lst-kix_5hjxj1ghwghx-1>li:before{content:"\0025cb   "}.lst-kix_haj85nxwaneu-0>li{counter-increment:lst-ctn-kix_haj85nxwaneu-0}.lst-kix_5hjxj1ghwghx-2>li:before{content:"\0025a0   "}ol.lst-kix_haj85nxwaneu-4.start{counter-reset:lst-ctn-kix_haj85nxwaneu-4 0}.lst-kix_haj85nxwaneu-1>li{counter-increment:lst-ctn-kix_haj85nxwaneu-1}.lst-kix_haj85nxwaneu-4>li{counter-increment:lst-ctn-kix_haj85nxwaneu-4}ol.lst-kix_haj85nxwaneu-1.start{counter-reset:lst-ctn-kix_haj85nxwaneu-1 0}.lst-kix_haj85nxwaneu-7>li{counter-increment:lst-ctn-kix_haj85nxwaneu-7}.lst-kix_5hjxj1ghwghx-7>li:before{content:"\0025cb   "}.lst-kix_5hjxj1ghwghx-8>li:before{content:"\0025a0   "}ol.lst-kix_haj85nxwaneu-5.start{counter-reset:lst-ctn-kix_haj85nxwaneu-5 0}ol.lst-kix_haj85nxwaneu-8.start{counter-reset:lst-ctn-kix_haj85nxwaneu-8 0}.lst-kix_haj85nxwaneu-2>li{counter-increment:lst-ctn-kix_haj85nxwaneu-2}ol.lst-kix_haj85nxwaneu-2.start{counter-reset:lst-ctn-kix_haj85nxwaneu-2 0}ol.lst-kix_haj85nxwaneu-6.start{counter-reset:lst-ctn-kix_haj85nxwaneu-6 0}.lst-kix_haj85nxwaneu-3>li{counter-increment:lst-ctn-kix_haj85nxwaneu-3}ol.lst-kix_haj85nxwaneu-3.start{counter-reset:lst-ctn-kix_haj85nxwaneu-3 0}.lst-kix_5hjxj1ghwghx-0>li:before{content:"\0025cf   "}ul.lst-kix_5hjxj1ghwghx-8{list-style-type:none}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}ul.lst-kix_5hjxj1ghwghx-0{list-style-type:none}ol.lst-kix_haj85nxwaneu-1{list-style-type:none}ul.lst-kix_5hjxj1ghwghx-1{list-style-type:none}ol.lst-kix_haj85nxwaneu-2{list-style-type:none}ul.lst-kix_5hjxj1ghwghx-2{list-style-type:none}ul.lst-kix_5hjxj1ghwghx-3{list-style-type:none}ol.lst-kix_haj85nxwaneu-0{list-style-type:none}ol.lst-kix_haj85nxwaneu-0.start{counter-reset:lst-ctn-kix_haj85nxwaneu-0 0}ul.lst-kix_5hjxj1ghwghx-4{list-style-type:none}ul.lst-kix_5hjxj1ghwghx-5{list-style-type:none}ul.lst-kix_5hjxj1ghwghx-6{list-style-type:none}ul.lst-kix_5hjxj1ghwghx-7{list-style-type:none}.lst-kix_haj85nxwaneu-5>li{counter-increment:lst-ctn-kix_haj85nxwaneu-5}ol.lst-kix_haj85nxwaneu-7{list-style-type:none}ol.lst-kix_haj85nxwaneu-8{list-style-type:none}.lst-kix_haj85nxwaneu-8>li{counter-increment:lst-ctn-kix_haj85nxwaneu-8}ol.lst-kix_haj85nxwaneu-5{list-style-type:none}ol.lst-kix_haj85nxwaneu-6{list-style-type:none}ol.lst-kix_haj85nxwaneu-3{list-style-type:none}ol.lst-kix_haj85nxwaneu-4{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c2{border-right-style:solid;padding-top:0pt;border-top-width:0pt;border-right-width:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.15;page-break-after:avoid;border-left-width:0pt;border-top-style:solid;background-color:#ffffff;border-left-style:solid;border-bottom-width:0pt;border-bottom-style:solid;orphans:2;widows:2;text-align:left;padding-right:0pt}.c7{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c3{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Open Sans";font-style:normal}.c13{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Open Sans";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Open Sans";font-style:normal}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c11{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c8{font-size:12pt;font-family:"Open Sans";font-weight:400}.c12{font-weight:400;font-family:"Open Sans"}.c10{margin-left:36pt;padding-left:0pt}.c0{padding:0;margin:0}.c9{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c11 doc-content"><div><p class="c4 c9"><span class="c5"></span></p></div><h1 class="c7" id="h.5rakhrqatk3p"><span class="c12">Overview</span></h1><h1 class="c2" id="h.wtixy13xbhaw"><span class="c1">In this assignment, we implemented 2D and 3D bezier curves as well as various mesh algorithms. De Casteljau&#39;s algorithm was used to evaluate Bezier curves with interactive control point modifications. Extending this to Bezier surfaces, we showcased the evaluation of a teapot surface. Area-weighted vertex normals were implemented for shading, enhancing the shading of objects. We also implemented edge flip and split operations, displaying mesh transformations before and after these operations. Loop subdivision was applied to refine triangular meshes, with observations made on mesh behavior. </span></h1><h1 class="c2" id="h.widr38ygcv54"><span class="c6">Part 1</span></h1><p class="c4"><span class="c1">In de Casteljau&rsquo;s algorithm, you find all points along the curve by recursively lerping down from control points. You interpolate t from [0,1] and then for that value of t recursively lerp. Each lerp level reduces the amount of line segments by 1, until you get to the final point on the line segment that is part of the curve.</span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c8">Implementation: </span><span class="c1">to implement a function returning the intermediate control points at the next subdivision level, we do the following. For each control point at the current subdivision level, we perform a linear interpolation on that point p and p+1 for parameter t. That gives us a control point at the next subdivision level. We do this for all control points at the current subdivision level except for the last (which has no p+1 neighbor) and push all lerped points to a vector&mdash;which contains all control points for the next subdivision level when the loop terminates. </span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c1">Screenshots:</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 301.36px; height: 172.07px;"><img alt="" src="images/image4.png" style="width: 415.12px; height: 289.66px; margin-left: -43.24px; margin-top: -30.56px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 279.50px; height: 171.68px;"><img alt="" src="images/image18.png" style="width: 386.71px; height: 263.97px; margin-left: -40.28px; margin-top: -25.25px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 290.50px; height: 176.42px;"><img alt="" src="images/image9.png" style="width: 389.00px; height: 269.30px; margin-left: -38.03px; margin-top: -25.56px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 289.50px; height: 171.93px;"><img alt="" src="images/image8.png" style="width: 394.43px; height: 275.55px; margin-left: -41.72px; margin-top: -25.91px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 286.50px; height: 169.61px;"><img alt="" src="images/image20.png" style="width: 396.40px; height: 238.85px; margin-left: -42.56px; margin-top: -25.44px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 290.21px; height: 166.53px;"><img alt="" src="images/image16.png" style="width: 367.05px; height: 260.62px; margin-left: -26.86px; margin-top: -23.15px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c1">Slightly different bezier curve (last two points changed)</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 486.62px; height: 327.47px;"><img alt="" src="images/image17.png" style="width: 486.62px; height: 327.47px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h1 class="c7" id="h.q1wutk9fitau"><span class="c13">Part 2</span></h1><p class="c4"><span class="c1">Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to evaluate Bezier surfaces.</span></p><p class="c4"><span class="c1">The de Casteljau algorithm extends to bezier surfaces easily as Bezier surfaces are represented as a u,v grid of control points. Simply evaluate point u the four bezier curves in u, and then use those curves to calculate the curve in v. This way, the entire surface can be generated with the piecewise separable application of bezier curves.</span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c8">Implementation: </span><span class="c1">The evaluateStep method is implemented similarly as in part 1 for 2D vectors, interpolating between p and p+1 control points. This time, we also implement an evaluation function to find the point on the Bezier surface given parameter (u, v). We have an n by n grid of control points. </span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 401.00px; height: 329.00px;"><img alt="" src="images/image12.png" style="width: 401.00px; height: 329.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h1 class="c7" id="h.u9lgzepg8gsn"><span class="c13">Part 3</span></h1><p class="c4"><span class="c1">Briefly explain how you implemented the area-weighted vertex normals.</span></p><p class="c4"><span class="c1">I implemented area-weighted vertex normals by doing the following for each vertex v:</span></p><ol class="c0 lst-kix_haj85nxwaneu-0 start" start="1"><li class="c4 c10 li-bullet-0"><span class="c1">I start at a halfedge (halfedge())</span></li><li class="c4 c10 li-bullet-0"><span class="c8">I </span><span class="c8">get the</span><span class="c8">&nbsp;</span><span class="c8">twin</span><span class="c1">. The face the twin is on is the normal I am then calculating</span></li><li class="c4 c10 li-bullet-0"><span class="c1">I calculate vector v1 with vertex v - twin-&gt;vertex</span></li><li class="c4 c10 li-bullet-0"><span class="c1">I calculate vector v2 with twin-&gt;next-&gt;twin-&gt;vertex - v</span></li><li class="c4 c10 li-bullet-0"><span class="c1">This gives me the two vectors adjacent to each other on the face with the vertex in between, in counterclockwise directions (so that the vertex normal points outwards)</span></li><li class="c4 c10 li-bullet-0"><span class="c1">I then cross v1 and v2 and add it to an accumulator</span></li></ol><p class="c4"><span class="c1">At the end, I normalize the accumulator by dividing by its magnitude.</span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c1">Screenshots:</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 302.69px; height: 206.19px;"><img alt="" src="images/image1.png" style="width: 302.69px; height: 206.19px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 293.50px; height: 204.72px;"><img alt="" src="images/image22.png" style="width: 293.50px; height: 217.93px; margin-left: 0.00px; margin-top: -0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h1 class="c7" id="h.83nwpi38trke"><span class="c6">Part 4</span></h1><p class="c4"><span class="c1">To implement the edge flip operation, we extracted all the objects relevant to the flip operation; all the half edges, vertices, edges, and faces. We then updated all the half edges, vertices, edges and faces to reflect the flip. We wrote down a diagram of two triangles (as a simulated flip) and labeled each and every vertex, face, half-edge and edge. This helped get rid of any bugs in the code.</span></p><p class="c4"><span class="c1">Before after flips</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 301.61px; height: 165.37px;"><img alt="" src="images/image14.png" style="width: 301.61px; height: 165.37px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 302.21px; height: 171.73px;"><img alt="" src="images/image7.png" style="width: 302.21px; height: 184.61px; margin-left: 0.00px; margin-top: -12.88px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c1">No eventful debugging journey.</span></p><h1 class="c7" id="h.yienz2ajnu5j"><span class="c6">Part 5</span></h1><p class="c4"><span class="c3">Briefly explain how you implemented the edge split operation and describe any interesting implementation / debugging tricks you have used.</span></p><p class="c4"><span class="c1">We implemented the edge split operation by getting every single half edge, edge, vertex, and face, then creating a new vertex and three edges, and then properly setting every single object to reflect the update. Drawing out the two triangles, labeling every old object, and then drawing the resulting split and each object in the split proved immensely useful.</span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c3">Show screenshots of a mesh before and after some edge splits.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 269.68px; height: 288.21px;"><img alt="" src="images/image5.png" style="width: 269.68px; height: 288.21px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 267.50px; height: 292.31px;"><img alt="" src="images/image2.png" style="width: 267.50px; height: 292.31px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c3">Show screenshots of a mesh before and after a combination of both edge splits and edge flips.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 241.43px; height: 242.50px;"><img alt="" src="images/image11.png" style="width: 241.43px; height: 242.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 257.90px; height: 244.50px;"><img alt="" src="images/image6.png" style="width: 257.90px; height: 244.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h1 class="c7" id="h.2l0rwn2y1th8"><span class="c6">Part 6</span></h1><p class="c4"><span class="c3">Briefly explain how you implemented the loop subdivision and describe any interesting implementation / debugging tricks you have used:</span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c1">We implemented loop subdivision by following the recommended approach; first, we computed the new positions for each old vertex and stored them in v-&gt;newPosition.</span></p><p class="c4"><span class="c1">Then we computed the new positions for every new vertex, and then stored them in the edge that would be split to produce the new vertex; e-&gt;newPosition.</span></p><p class="c4"><span class="c1">Then we split every edge in the old mesh; to make sure we did not recursively split edges, we checked that each edge we split is between two old vertices. When we split the edge, the two new edges created were marked as new, while the old edge that was split into two was marked as old. We also stored the e-&gt;newPosition into the new vertex&rsquo;s v-&gt;newPosition, so that later we would know what position to load into the new vertex.</span></p><p class="c4"><span class="c1">Then we checked every new edge which connected an old and new vertex and flipped it. Once this was done, we set v-&gt;position = v-&gt;newPosition, updating the position of all vertices in the mesh.</span></p><p class="c4"><span class="c1">One debugging trick was instead of setting v-&gt;isNew or e-&gt;isNew to false in preparation for the next iteration, at the start we set all of them to false.</span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c3">Take some notes, as well as some screenshots, of your observations on how meshes behave after loop subdivision. What happens to sharp corners and edges? </span></p><p class="c4"><span class="c1">Sharp corners and edges get heavily smoothed over. </span></p><p class="c4"><span class="c3">Can you reduce this effect by pre-splitting some edges?</span></p><p class="c4"><span class="c1">Pre-splitting the edges adjacent to the sharp corner / pre-splitting the sharp edge multiple times will reduce the smoothing effect</span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4"><span class="c3">Load dae/cube.dae. Perform several iterations of loop subdivision on the cube. </span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 190.26px; height: 205.21px;"><img alt="" src="images/image10.png" style="width: 190.26px; height: 199.45px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 206.27px; height: 207.21px;"><img alt="" src="images/image19.png" style="width: 206.27px; height: 207.21px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 194.29px; height: 217.26px;"><img alt="" src="images/image3.png" style="width: 194.29px; height: 217.26px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c3">Notice that the cube becomes slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips and splits so that the cube subdivides symmetrically? Document these effects and explain why they occur. Also explain how your pre-processing helps alleviate the effects.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 208.17px; height: 234.50px;"><img alt="" src="images/image21.png" style="width: 208.17px; height: 234.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 192.72px; height: 207.50px;"><img alt="" src="images/image13.png" style="width: 192.72px; height: 207.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 198.26px; height: 212.54px;"><img alt="" src="images/image15.png" style="width: 198.26px; height: 212.54px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c1">Yes, preprocessing can reduce the asymmetry so that the cube subdivides symmetrically. The asymmetric effects occur because when loop subdivision occurs, the single diagonal on each face of the cube causes the new vertex to sample more from the vertices on the endpoints of the edge, skewing the new samples towards those points. By adding more splits symmetrically, new vertices on a face now sample equally from each corner of the face.</span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4 c9"><span class="c1"></span></p><p class="c4 c9"><span class="c5"></span></p><p class="c4 c9"><span class="c5"></span></p><p class="c4 c9"><span class="c5"></span></p><p class="c4 c9"><span class="c5"></span></p></body></html>